import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.backends.backend_pdf import PdfPages
from io import BytesIO
import base64
import streamlit as st
import calendar
import os
from matplotlib.image import imread
import json
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage

# Add JSON encoder for NumPy types
class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, (np.integer, np.int64)):
            return int(obj)
        elif isinstance(obj, (np.floating, np.float64)):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        return super(NumpyEncoder, self).default(obj)

def generate_employee_report(employee_id, employee_data, payroll_df, leave_df, productivity_df):
    """
    Generate a comprehensive PDF report for an employee.
    
    Args:
        employee_id: The ID of the employee
        employee_data: Series containing employee information
        payroll_df: DataFrame with payroll history
        leave_df: DataFrame with leave records
        productivity_df: DataFrame with productivity metrics
        
    Returns:
        BytesIO buffer containing the PDF report
    """
    # Create a BytesIO buffer to save the PDF to
    buffer = BytesIO()
    
    # Set up the PDF with matplotlib
    with PdfPages(buffer) as pdf:
        # Title page
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Title
        if 'full_name' in employee_data:
            employee_name = employee_data['full_name']
        elif 'first_name' in employee_data and 'last_name' in employee_data:
            employee_name = f"{employee_data['first_name']} {employee_data['last_name']}"
        else:
            employee_name = f"Employee #{employee_id}"
            
        ax.text(0.5, 0.9, "Employee Report", fontsize=24, weight='bold', ha='center')
        ax.text(0.5, 0.85, employee_name, fontsize=20, ha='center')
        ax.text(0.5, 0.8, f"ID: {employee_id}", fontsize=16, ha='center')
        
        # Date of report
        ax.text(0.5, 0.75, f"Report Date: {datetime.now().strftime('%d %b %Y')}", fontsize=12, ha='center')
        
        # Add company logo placeholder
        ax.text(0.5, 0.5, "Farm Group Logo", fontsize=16, ha='center', bbox=dict(facecolor='lightgray', alpha=0.5))

        # Add company logo (replacing placeholder)
        try:
            logo_path = "PeopleRadarLogo.jpeg"
            if os.path.exists(logo_path):
                logo_img = imread(logo_path)
                logo_ax = fig.add_axes([0.35, 0.45, 0.3, 0.3])
                logo_ax.imshow(logo_img)
                logo_ax.axis('off')
                
                # Remove the placeholder text since we have the actual logo
                ax.texts = ax.texts[:-1]
            else:
                ax.text(0.5, 0.5, "Logo not found", fontsize=16, ha='center', bbox=dict(facecolor='lightgray', alpha=0.5))
        except Exception as e:
            ax.text(0.5, 0.5, "Error loading logo", fontsize=16, ha='center', bbox=dict(facecolor='lightgray', alpha=0.5))
        
        # Add footer
        ax.text(0.5, 0.1, "CONFIDENTIAL - FOR INTERNAL USE ONLY", fontsize=10, ha='center', style='italic')
        ax.text(0.5, 0.05, "Generated by People Radar Dashboard", fontsize=8, ha='center')
        
        pdf.savefig(fig)
        plt.close()
        
        # Employee Profile page
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Page title
        ax.text(0.5, 0.95, "Employee Profile", fontsize=16, weight='bold', ha='center')
        
        # Add worker image
        try:
            worker_img_path = "worker_head.png"
            if os.path.exists(worker_img_path):
                worker_img = imread(worker_img_path)
                # Position the image in the top right corner
                worker_img_ax = fig.add_axes([0.7, 0.8, 0.2, 0.2])
                worker_img_ax.imshow(worker_img)
                worker_img_ax.axis('off')
        except Exception as e:
            # Silently fail if image cannot be loaded
            pass
        
        # Personal Information Section
        ax.text(0.1, 0.9, "Personal Information", fontsize=14, weight='bold')
        
        y_pos = 0.85
        personal_info = []
        
        personal_info.append(f"Name: {employee_name}")
        personal_info.append(f"Employee ID: {employee_id}")
        
        if 'date_of_birth' in employee_data:
            personal_info.append(f"Date of Birth: {employee_data['date_of_birth'].strftime('%d %b %Y')}")
            
            # Calculate age
            today = datetime.now()
            age = int((today - employee_data['date_of_birth']).days / 365.25)
            personal_info.append(f"Age: {age} years")
        
        if 'gender' in employee_data:
            personal_info.append(f"Gender: {employee_data['gender']}")
        
        if 'ethnicity' in employee_data:
            personal_info.append(f"Ethnicity: {employee_data['ethnicity']}")
        
        if 'has_disability' in employee_data:
            personal_info.append(f"Disability Status: {'Yes' if employee_data['has_disability'] else 'No'}")
        
        # Print personal info
        for info in personal_info:
            ax.text(0.1, y_pos, info, fontsize=10)
            y_pos -= 0.05
        
        # Employment Details Section
        ax.text(0.1, y_pos - 0.05, "Employment Details", fontsize=14, weight='bold')
        y_pos -= 0.1
        
        employment_info = []
        
        if 'job_title' in employee_data:
            employment_info.append(f"Job Title: {employee_data['job_title']}")
        
        if 'department' in employee_data:
            employment_info.append(f"Department: {employee_data['department']}")
        
        if 'location' in employee_data:
            employment_info.append(f"Location: {employee_data['location']}")
        
        if 'worker_type' in employee_data:
            employment_info.append(f"Worker Type: {employee_data['worker_type']}")
        
        if 'join_date' in employee_data:
            employment_info.append(f"Join Date: {employee_data['join_date'].strftime('%d %b %Y')}")
            
            # Calculate tenure
            today = datetime.now()
            tenure_days = (today - employee_data['join_date']).days
            years = tenure_days // 365
            months = (tenure_days % 365) // 30
            employment_info.append(f"Tenure: {years} years, {months} months")
        
        if 'manager_id' in employee_data and not pd.isna(employee_data['manager_id']):
            employment_info.append(f"Manager ID: {int(employee_data['manager_id'])}")
        
        # Print employment info
        for info in employment_info:
            ax.text(0.1, y_pos, info, fontsize=10)
            y_pos -= 0.05
        
        pdf.savefig(fig)
        plt.close()
        
        # Performance and Compensation page
        if not productivity_df.empty or not payroll_df.empty:
            fig, ax = plt.subplots(figsize=(8.5, 11))
            ax.axis('off')
            
            # Page title
            ax.text(0.5, 0.95, "Performance & Compensation", fontsize=16, weight='bold', ha='center')
            
            # Compensation Section
            if not payroll_df.empty:
                ax.text(0.1, 0.9, "Compensation Summary", fontsize=14, weight='bold')
                
                # Filter payroll data for this employee
                employee_payroll = payroll_df[payroll_df['employee_id'] == employee_id].copy()
                
                if not employee_payroll.empty:
                    # Get latest salary
                    latest_month = employee_payroll['month'].max()
                    latest_salary = employee_payroll[employee_payroll['month'] == latest_month]['base_salary'].iloc[0]
                    
                    y_pos = 0.85
                    ax.text(0.1, y_pos, f"Current Monthly Salary: R {latest_salary:,.2f}", fontsize=10)
                    y_pos -= 0.05
                    
                    # Calculate average overtime
                    avg_overtime = employee_payroll['overtime_pay'].mean()
                    ax.text(0.1, y_pos, f"Average Monthly Overtime: R {avg_overtime:,.2f}", fontsize=10)
                    y_pos -= 0.05
                    
                    # Calculate salary growth
                    first_salary = employee_payroll.sort_values('month')['base_salary'].iloc[0]
                    salary_growth = ((latest_salary / first_salary) - 1) * 100 if first_salary > 0 else 0
                    ax.text(0.1, y_pos, f"Salary Growth: {salary_growth:.2f}%", fontsize=10)
                    y_pos -= 0.05
                    
                    # Plot salary history if there's enough data
                    if len(employee_payroll) > 1:
                        y_pos -= 0.05
                        salary_ax = fig.add_axes([0.1, y_pos - 0.3, 0.8, 0.3])
                        
                        # Sort by month
                        employee_payroll = employee_payroll.sort_values('month')
                        
                        # Convert month to datetime for better plotting
                        employee_payroll['month_dt'] = pd.to_datetime(employee_payroll['month'] + '-01')
                        
                        # Plot salary history
                        salary_ax.plot(employee_payroll['month_dt'], employee_payroll['base_salary'], 
                                     marker='o', linestyle='-', color='#1E88E5')
                        
                        # Format axes
                        salary_ax.set_title("Salary History", fontsize=12)
                        salary_ax.set_ylabel("Monthly Base Salary (R)", fontsize=10)
                        salary_ax.grid(True, linestyle='--', alpha=0.7)
                        
                        # Format x-axis as dates
                        salary_ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
                        plt.setp(salary_ax.get_xticklabels(), rotation=45, ha='right')
                        
                        # Format y-axis as currency
                        salary_ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f"R {x:,.0f}"))
                        
                        y_pos -= 0.35
            
            # Performance Section
            if not productivity_df.empty:
                ax.text(0.1, y_pos - 0.05, "Performance Summary", fontsize=14, weight='bold')
                y_pos -= 0.1
                
                # Filter productivity data for this employee
                employee_performance = productivity_df[productivity_df['employee_id'] == employee_id].copy()
                
                if not employee_performance.empty:
                    # Calculate average metrics
                    avg_performance = employee_performance['performance_score'].mean()
                    avg_productivity = employee_performance['productivity_level'].mean()
                    avg_days_worked = employee_performance['days_worked'].mean()
                    total_incidents = employee_performance['incident_count'].sum()
                    
                    ax.text(0.1, y_pos, f"Average Performance Score: {avg_performance:.2f} / 5.0", fontsize=10)
                    y_pos -= 0.05
                    ax.text(0.1, y_pos, f"Average Productivity Level: {avg_productivity:.2f}", fontsize=10)
                    y_pos -= 0.05
                    ax.text(0.1, y_pos, f"Average Days Worked per Month: {avg_days_worked:.1f} days", fontsize=10)
                    y_pos -= 0.05
                    ax.text(0.1, y_pos, f"Total Incidents: {total_incidents}", fontsize=10)
                    y_pos -= 0.05
                    
                    # Plot performance history if there's enough data
                    if len(employee_performance) > 1:
                        y_pos -= 0.05
                        perf_ax = fig.add_axes([0.1, y_pos - 0.3, 0.8, 0.3])
                        
                        # Sort by month
                        employee_performance = employee_performance.sort_values('month')
                        
                        # Convert month to datetime for better plotting
                        employee_performance['month_dt'] = pd.to_datetime(employee_performance['month'] + '-01')
                        
                        # Plot performance history
                        perf_ax.plot(employee_performance['month_dt'], employee_performance['performance_score'], 
                                   marker='o', linestyle='-', color='#1E88E5')
                        
                        # Format axes
                        perf_ax.set_title("Performance Score History", fontsize=12)
                        perf_ax.set_ylabel("Performance Score (1-5)", fontsize=10)
                        perf_ax.set_ylim([1, 5])
                        perf_ax.grid(True, linestyle='--', alpha=0.7)
                        
                        # Format x-axis as dates
                        perf_ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
                        plt.setp(perf_ax.get_xticklabels(), rotation=45, ha='right')
                        
                        # Add AI Performance Insights page
                        try:
                            # Save current page and create a new one for AI insights
                            pdf.savefig(fig)
                            plt.close()
                            
                            # Create a new page for AI insights
                            fig, ax = plt.subplots(figsize=(8.5, 11))
                            ax.axis('off')
                            
                            # Page title
                            ax.text(0.5, 0.95, "AI Performance Insights", fontsize=16, weight='bold', ha='center')
                            
                            # Prepare data for AI analysis
                            perf_data = employee_performance.sort_values('month')
                            
                            # Calculate trends
                            first_month = perf_data.iloc[0]['month']
                            last_month = perf_data.iloc[-1]['month']
                            
                            first_performance = float(perf_data.iloc[0]['performance_score'])
                            last_performance = float(perf_data.iloc[-1]['performance_score'])
                            perf_change = float(last_performance - first_performance)
                            
                            first_productivity = float(perf_data.iloc[0]['productivity_level'])
                            last_productivity = float(perf_data.iloc[-1]['productivity_level'])
                            prod_change = float(last_productivity - first_productivity)
                            
                            total_incidents = int(perf_data['incident_count'].sum())
                            avg_incidents = float(perf_data['incident_count'].mean())
                            recent_incidents = int(perf_data.iloc[-3:]['incident_count'].sum()) if len(perf_data) >= 3 else None
                            
                            # Convert performance history to ensure JSON serializable
                            performance_history = []
                            for _, row in perf_data[['month', 'performance_score', 'productivity_level', 'incident_count']].iterrows():
                                performance_history.append({
                                    'month': row['month'],
                                    'performance_score': float(row['performance_score']),
                                    'productivity_level': float(row['productivity_level']),
                                    'incident_count': int(row['incident_count'])
                                })
                            
                            # Prepare the data object for AI
                            analysis_data = {
                                "employee_info": {
                                    "id": int(employee_id),
                                    "name": employee_name,
                                    "department": employee_data.get('department', 'Unknown'),
                                    "job_title": employee_data.get('job_title', 'Unknown'),
                                },
                                "performance_history": performance_history,
                                "summary_metrics": {
                                    "time_period": f"{first_month} to {last_month}",
                                    "performance_change": perf_change,
                                    "productivity_change": prod_change,
                                    "total_incidents": total_incidents,
                                    "avg_incidents_per_month": avg_incidents,
                                    "recent_incidents": recent_incidents
                                }
                            }
                            
                            # Create prompt for AI
                            prompt = f"""
                            You are a farm workforce analytics expert providing insights for a PDF report. Analyze this employee's performance data concisely.
                            
                            DATA:
                            {json.dumps(analysis_data, indent=2, cls=NumpyEncoder)}
                            
                            Provide a concise 1-2 paragraph analysis for each:
                            1. Performance trend: Is performance improving, declining, or stable? Be specific.
                            2. Productivity trend: Is productivity improving, declining, or stable? Be specific.
                            3. Incident analysis: Evaluate incidents. Any concerns?
                            4. Overall assessment: Is the employee's trajectory positive or concerning?
                            5. Management recommendations: What actions should be taken?
                            
                            Keep your entire response under 600 words for a printed report.
                            """
                            
                            # Get AI insights
                            try:
                                model = ChatOpenAI(
                                    model="gpt-4o-mini", 
                                    temperature=0.7
                                )
                                
                                response = model.invoke([
                                    HumanMessage(content=prompt)
                                ])
                                
                                # Parse the response and add to the report
                                ai_analysis = response.content
                                
                                # Display AI insights with proper formatting
                                y_pos = 0.88
                                for line in ai_analysis.split('\n'):
                                    if line.strip():
                                        # Check if it's a heading
                                        if line.strip().startswith('##') or line.strip().startswith('# '):
                                            # Remove the # and add as a heading
                                            heading = line.strip().lstrip('#').strip()
                                            ax.text(0.1, y_pos, heading, fontsize=12, weight='bold')
                                            y_pos -= 0.04
                                        else:
                                            # Wrap text to fit page width
                                            wrapped_lines = []
                                            current_line = ""
                                            for word in line.split():
                                                if len(current_line + " " + word) > 80:  # Character limit per line
                                                    wrapped_lines.append(current_line)
                                                    current_line = word
                                                else:
                                                    if current_line:
                                                        current_line += " " + word
                                                    else:
                                                        current_line = word
                                            if current_line:
                                                wrapped_lines.append(current_line)
                                            
                                            for wrapped in wrapped_lines:
                                                ax.text(0.1, y_pos, wrapped, fontsize=10)
                                                y_pos -= 0.03
                                            
                                            # Add extra space after paragraphs
                                            if line.strip() == "":
                                                y_pos -= 0.02
                            
                            except Exception as e:
                                # If AI insights fail, add a message
                                ax.text(0.1, y_pos, "AI insights could not be generated.", fontsize=12)
                                y_pos -= 0.05
                                ax.text(0.1, y_pos, f"Error: {str(e)}", fontsize=10)
                                
                            # Add note about AI-generated content
                            ax.text(0.1, 0.05, "Note: These insights are generated by AI and should be reviewed by a human manager.", 
                                   fontsize=8, style='italic')
                            
                        except Exception as e:
                            # If anything fails during AI insight generation, continue with the report
                            print(f"Error generating AI insights for employee report: {str(e)}")
            
            pdf.savefig(fig)
            plt.close()
        
        # Leave History page
        if not leave_df.empty:
            # Filter leave data for this employee
            employee_leave = leave_df[leave_df['employee_id'] == employee_id].copy()
            
            if not employee_leave.empty:
                fig, ax = plt.subplots(figsize=(8.5, 11))
                ax.axis('off')
                
                # Page title
                ax.text(0.5, 0.95, "Leave History", fontsize=16, weight='bold', ha='center')
                
                # Leave summary
                ax.text(0.1, 0.9, "Leave Summary", fontsize=14, weight='bold')
                
                # Calculate leave totals
                total_leave_days = employee_leave['duration_days'].sum()
                leave_by_type = employee_leave.groupby('leave_type')['duration_days'].sum()
                
                y_pos = 0.85
                ax.text(0.1, y_pos, f"Total Leave Days: {total_leave_days}", fontsize=10)
                y_pos -= 0.05
                
                # Print leave by type
                for leave_type, days in leave_by_type.items():
                    ax.text(0.1, y_pos, f"{leave_type}: {days} days", fontsize=10)
                    y_pos -= 0.05
                
                # Leave bar chart
                if len(leave_by_type) > 0:
                    y_pos -= 0.05
                    leave_ax = fig.add_axes([0.1, y_pos - 0.3, 0.8, 0.3])
                    
                    # Prepare data for chart
                    leave_types = leave_by_type.index.tolist()
                    leave_days = leave_by_type.values
                    
                    # Create bar chart
                    bars = leave_ax.bar(leave_types, leave_days, color='#1E88E5')
                    
                    # Add data labels
                    for bar in bars:
                        height = bar.get_height()
                        leave_ax.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                                    f"{height:.0f}",
                                    ha='center', va='bottom', fontsize=9)
                    
                    # Format axes
                    leave_ax.set_title("Leave Days by Type", fontsize=12)
                    leave_ax.set_ylabel("Days", fontsize=10)
                    leave_ax.grid(True, axis='y', linestyle='--', alpha=0.7)
                    
                    y_pos -= 0.35
                
                # Leave table
                y_pos -= 0.05
                ax.text(0.1, y_pos, "Recent Leave Records", fontsize=12, weight='bold')
                y_pos -= 0.05
                
                # Table headers
                col_labels = ['Start Date', 'End Date', 'Duration', 'Leave Type', 'Status']
                col_widths = [0.2, 0.2, 0.1, 0.25, 0.15]  # Proportional column widths
                
                # Calculate column positions
                col_positions = [0.1]  # Start position
                for width in col_widths[:-1]:
                    col_positions.append(col_positions[-1] + width)
                
                # Draw table headers
                for i, (label, pos) in enumerate(zip(col_labels, col_positions)):
                    ax.text(pos, y_pos, label, fontsize=9, weight='bold')
                
                y_pos -= 0.03
                ax.axhline(y=y_pos, xmin=0.1, xmax=0.9, color='black', linewidth=0.5)
                y_pos -= 0.03
                
                # Sort leave records by start date (descending)
                recent_leave = employee_leave.sort_values('start_date', ascending=False).head(10)
                
                # Draw table rows
                for _, row in recent_leave.iterrows():
                    start_date = row['start_date'].strftime('%d %b %Y')
                    end_date = row['end_date'].strftime('%d %b %Y')
                    duration = f"{row['duration_days']} days"
                    leave_type = row['leave_type']
                    status = row['status']
                    
                    # Print row values
                    ax.text(col_positions[0], y_pos, start_date, fontsize=8)
                    ax.text(col_positions[1], y_pos, end_date, fontsize=8)
                    ax.text(col_positions[2], y_pos, duration, fontsize=8)
                    ax.text(col_positions[3], y_pos, leave_type, fontsize=8)
                    ax.text(col_positions[4], y_pos, status, fontsize=8)
                    
                    y_pos -= 0.03
                    
                    # Stop if we're running out of space
                    if y_pos < 0.1:
                        break
                
                pdf.savefig(fig)
                plt.close()
        
        # Add a final page with legal disclaimer
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Page title
        ax.text(0.5, 0.95, "Legal Information", fontsize=16, weight='bold', ha='center')
        
        # Disclaimer
        disclaimer = [
            "This report contains confidential information and is intended solely for internal use.",
            "The information contained in this report may not be disclosed to any third party without prior consent.",
            "This report was generated automatically by the People Radar Dashboard system.",
            "The information is provided as-is and the company makes no guarantees about its accuracy or completeness.",
            "",
            f"Report generated on {datetime.now().strftime('%d %b %Y at %H:%M')}",
            f"Employee ID: {employee_id}"
        ]
        
        y_pos = 0.85
        for line in disclaimer:
            ax.text(0.1, y_pos, line, fontsize=10)
            y_pos -= 0.05
        
        pdf.savefig(fig)
        plt.close()
    
    # Reset buffer position to the beginning
    buffer.seek(0)
    
    return buffer

def generate_department_report(department, employees_df, payroll_df, productivity_df, leave_df):
    """
    Generate a comprehensive PDF report for a department.
    
    Args:
        department: The department name
        employees_df: DataFrame with employee data
        payroll_df: DataFrame with payroll data
        productivity_df: DataFrame with productivity metrics
        leave_df: DataFrame with leave records
        
    Returns:
        BytesIO buffer containing the PDF report
    """
    # Create a BytesIO buffer to save the PDF to
    buffer = BytesIO()
    
    # Filter data for the department
    dept_employees = employees_df[employees_df['department'] == department]
    
    # Set up the PDF with matplotlib
    with PdfPages(buffer) as pdf:
        # Title page
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Title
        ax.text(0.5, 0.9, "Department Report", fontsize=24, weight='bold', ha='center')
        ax.text(0.5, 0.85, department, fontsize=20, ha='center')
        
        # Date of report
        ax.text(0.5, 0.75, f"Report Date: {datetime.now().strftime('%d %b %Y')}", fontsize=12, ha='center')
        
        # Add company logo placeholder
        ax.text(0.5, 0.5, "Farm Group Logo", fontsize=16, ha='center', bbox=dict(facecolor='lightgray', alpha=0.5))

        # Add company logo
        try:
            logo_path = "PeopleRadarLogo.jpeg"
            if os.path.exists(logo_path):
                logo_img = imread(logo_path)
                logo_ax = fig.add_axes([0.35, 0.45, 0.3, 0.3])
                logo_ax.imshow(logo_img)
                logo_ax.axis('off')
            else:
                ax.text(0.5, 0.5, "Logo not found", fontsize=16, ha='center', bbox=dict(facecolor='lightgray', alpha=0.5))
        except Exception as e:
            ax.text(0.5, 0.5, "Error loading logo", fontsize=16, ha='center', bbox=dict(facecolor='lightgray', alpha=0.5))
        
        # Add footer
        ax.text(0.5, 0.1, "CONFIDENTIAL - FOR INTERNAL USE ONLY", fontsize=10, ha='center', style='italic')
        ax.text(0.5, 0.05, "Generated by People Radar Dashboard", fontsize=8, ha='center')
        
        pdf.savefig(fig)
        plt.close()
        
        # Department Overview page
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Page title
        ax.text(0.5, 0.95, "Department Overview", fontsize=16, weight='bold', ha='center')
        
        # Department Summary
        ax.text(0.1, 0.9, "Department Summary", fontsize=14, weight='bold')
        
        # Calculate metrics
        employee_count = len(dept_employees)
        
        # Worker types distribution
        worker_types = dept_employees['worker_type'].value_counts()
        permanent_count = worker_types.get('Permanent', 0)
        seasonal_count = worker_types.get('Seasonal', 0)
        contract_count = worker_types.get('Contract', 0)
        
        # Gender distribution if available
        gender_dist = None
        if 'gender' in dept_employees.columns:
            gender_dist = dept_employees['gender'].value_counts()
        
        # Summary statistics
        y_pos = 0.85
        ax.text(0.1, y_pos, f"Total Employees: {employee_count}", fontsize=12)
        y_pos -= 0.05
        
        ax.text(0.1, y_pos, "Employee Types:", fontsize=12)
        y_pos -= 0.04
        ax.text(0.15, y_pos, f"Permanent: {permanent_count} ({permanent_count/employee_count*100:.1f}%)" if employee_count > 0 else "Permanent: 0", fontsize=10)
        y_pos -= 0.03
        ax.text(0.15, y_pos, f"Seasonal: {seasonal_count} ({seasonal_count/employee_count*100:.1f}%)" if employee_count > 0 else "Seasonal: 0", fontsize=10)
        y_pos -= 0.03
        ax.text(0.15, y_pos, f"Contract: {contract_count} ({contract_count/employee_count*100:.1f}%)" if employee_count > 0 else "Contract: 0", fontsize=10)
        y_pos -= 0.05
        
        if gender_dist is not None:
            ax.text(0.1, y_pos, "Gender Distribution:", fontsize=12)
            y_pos -= 0.04
            for gender, count in gender_dist.items():
                ax.text(0.15, y_pos, f"{gender}: {count} ({count/employee_count*100:.1f}%)" if employee_count > 0 else f"{gender}: 0", fontsize=10)
                y_pos -= 0.03
        
        # Employee list (top 15)
        y_pos -= 0.05
        ax.text(0.1, y_pos, "Key Personnel", fontsize=14, weight='bold')
        y_pos -= 0.05
        
        # Identify managers or team leads
        manager_keywords = ['Manager', 'Supervisor', 'Lead', 'Team Lead', 'Foreman']
        is_manager = dept_employees['job_title'].str.contains('|'.join(manager_keywords), case=False, na=False)
        managers = dept_employees[is_manager].sort_values('worker_type')
        
        if not managers.empty:
            # Table headers
            col_labels = ['Name', 'Job Title', 'Worker Type']
            col_widths = [0.3, 0.3, 0.2]  # Proportional column widths
            
            # Calculate column positions
            col_positions = [0.1]  # Start position
            for width in col_widths[:-1]:
                col_positions.append(col_positions[-1] + width)
            
            # Draw table headers
            for i, (label, pos) in enumerate(zip(col_labels, col_positions)):
                ax.text(pos, y_pos, label, fontsize=11, weight='bold')
            
            y_pos -= 0.03
            ax.axhline(y=y_pos, xmin=0.1, xmax=0.9, color='black', linewidth=0.5)
            y_pos -= 0.03
            
            # Draw manager rows
            for i, (_, row) in enumerate(managers.head(15).iterrows()):
                name = f"{row.get('first_name', '')} {row.get('last_name', '')}" if 'first_name' in row and 'last_name' in row else f"Employee #{row['employee_id']}"
                job_title = row.get('job_title', 'N/A')
                worker_type = row.get('worker_type', 'N/A')
                
                ax.text(col_positions[0], y_pos, name, fontsize=10)
                ax.text(col_positions[1], y_pos, job_title, fontsize=10)
                ax.text(col_positions[2], y_pos, worker_type, fontsize=10)
                
                y_pos -= 0.03
        else:
            ax.text(0.1, y_pos, "No management personnel found in this department.", fontsize=10, style='italic')
        
        pdf.savefig(fig)
        plt.close()
        
        # Payroll Analysis page
        if not payroll_df.empty:
            # Filter payroll data for department
            dept_payroll = pd.merge(
                payroll_df,
                dept_employees[['employee_id']],
                on='employee_id',
                how='inner'
            )
            
            if not dept_payroll.empty:
                fig, ax = plt.subplots(figsize=(8.5, 11))
                ax.axis('off')
                
                # Page title
                ax.text(0.5, 0.95, "Payroll Analysis", fontsize=16, weight='bold', ha='center')
                
                # Financial Summary
                ax.text(0.1, 0.9, "Financial Summary", fontsize=14, weight='bold')
                
                # Aggregate monthly data
                latest_month = dept_payroll['month'].max()
                latest_payroll = dept_payroll[dept_payroll['month'] == latest_month]
                
                # Calculate payroll metrics
                total_monthly = latest_payroll['gross_pay'].sum()
                avg_salary = latest_payroll['base_salary'].mean()
                total_overtime = latest_payroll['overtime_pay'].sum()
                overtime_pct = (total_overtime / total_monthly * 100) if total_monthly > 0 else 0
                
                # Print financial summary
                y_pos = 0.85
                ax.text(0.1, y_pos, f"Latest Month: {latest_month}", fontsize=12)
                y_pos -= 0.05
                ax.text(0.1, y_pos, f"Total Monthly Payroll: R {total_monthly:,.2f}", fontsize=12)
                y_pos -= 0.04
                ax.text(0.1, y_pos, f"Average Salary: R {avg_salary:,.2f}", fontsize=12)
                y_pos -= 0.04
                ax.text(0.1, y_pos, f"Total Overtime: R {total_overtime:,.2f} ({overtime_pct:.1f}% of total)", fontsize=12)
                
                # Payroll trend chart
                y_pos -= 0.1
                payroll_ax = fig.add_axes([0.1, y_pos - 0.3, 0.8, 0.3])
                
                # Group by month
                monthly_totals = dept_payroll.groupby('month')['gross_pay'].sum().reset_index()
                monthly_totals = monthly_totals.sort_values('month')
                
                # Convert month to datetime for better plotting
                monthly_totals['month_dt'] = pd.to_datetime(monthly_totals['month'] + '-01')
                
                # Plot payroll trend
                payroll_ax.plot(monthly_totals['month_dt'], monthly_totals['gross_pay'], 
                               marker='o', linestyle='-', color='#1E88E5')
                
                # Format axes
                payroll_ax.set_title("Monthly Payroll Trend", fontsize=12)
                payroll_ax.set_ylabel("Total Payroll (R)", fontsize=10)
                payroll_ax.grid(True, linestyle='--', alpha=0.7)
                
                # Format x-axis as dates
                payroll_ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
                plt.setp(payroll_ax.get_xticklabels(), rotation=45, ha='right')
                
                # Format y-axis as currency
                payroll_ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f"R {x:,.0f}"))
                
                pdf.savefig(fig)
                plt.close()
        
        # Productivity Analysis page
        if not productivity_df.empty:
            # Filter productivity data for department
            dept_productivity = pd.merge(
                productivity_df,
                dept_employees[['employee_id']],
                on='employee_id',
                how='inner'
            )
            
            if not dept_productivity.empty:
                fig, ax = plt.subplots(figsize=(8.5, 11))
                ax.axis('off')
                
                # Page title
                ax.text(0.5, 0.95, "Productivity Analysis", fontsize=16, weight='bold', ha='center')
                
                # Performance Summary
                ax.text(0.1, 0.9, "Performance Summary", fontsize=14, weight='bold')
                
                # Latest month
                latest_month = dept_productivity['month'].max()
                latest_prod = dept_productivity[dept_productivity['month'] == latest_month]
                
                # Calculate metrics
                avg_performance = latest_prod['performance_score'].mean()
                avg_productivity = latest_prod['productivity_level'].mean()
                avg_days_worked = latest_prod['days_worked'].mean()
                total_incidents = latest_prod['incident_count'].sum()
                
                # Print performance summary
                y_pos = 0.85
                ax.text(0.1, y_pos, f"Latest Month: {latest_month}", fontsize=12)
                y_pos -= 0.05
                ax.text(0.1, y_pos, f"Average Performance Score: {avg_performance:.2f} / 5.0", fontsize=12)
                y_pos -= 0.05
                ax.text(0.1, y_pos, f"Average Productivity Level: {avg_productivity:.2f}", fontsize=12)
                y_pos -= 0.05
                ax.text(0.1, y_pos, f"Average Days Worked per Month: {avg_days_worked:.1f} days", fontsize=12)
                y_pos -= 0.05
                ax.text(0.1, y_pos, f"Total Incidents: {total_incidents}", fontsize=12)
                y_pos -= 0.05
                
                # Plot productivity history if there's enough data
                if len(dept_productivity) > 1:
                    y_pos -= 0.1
                    prod_ax = fig.add_axes([0.1, y_pos - 0.3, 0.8, 0.3])
                    
                    # Sort by month
                    dept_productivity = dept_productivity.sort_values('month')
                    
                    # Convert month to datetime for better plotting
                    dept_productivity['month_dt'] = pd.to_datetime(dept_productivity['month'] + '-01')
                    
                    # Plot productivity history
                    prod_ax.plot(dept_productivity['month_dt'], dept_productivity['productivity_level'], 
                                 marker='o', linestyle='-', color='#1E88E5')
                    
                    # Format axes
                    prod_ax.set_title("Productivity Level History", fontsize=12)
                    prod_ax.set_ylabel("Productivity Level (1-5)", fontsize=10)
                    prod_ax.set_ylim([1, 5])
                    prod_ax.grid(True, linestyle='--', alpha=0.7)
                    
                    # Format x-axis as dates
                    prod_ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
                    plt.setp(prod_ax.get_xticklabels(), rotation=45, ha='right')
                
                pdf.savefig(fig)
                plt.close()
        
        # Leave Analysis page
        if not leave_df.empty:
            # Filter leave data for department
            dept_leave = leave_df[leave_df['employee_id'].isin(dept_employees['employee_id'])].copy()
            
            if not dept_leave.empty:
                fig, ax = plt.subplots(figsize=(8.5, 11))
                ax.axis('off')
                
                # Page title
                ax.text(0.5, 0.95, "Leave Analysis", fontsize=16, weight='bold', ha='center')
                
                # Leave summary
                ax.text(0.1, 0.9, "Leave Summary", fontsize=14, weight='bold')
                
                # Calculate leave totals
                total_leave_days = dept_leave['duration_days'].sum()
                leave_by_type = dept_leave.groupby('leave_type')['duration_days'].sum()
                
                y_pos = 0.85
                ax.text(0.1, y_pos, f"Total Leave Days: {total_leave_days}", fontsize=10)
                y_pos -= 0.05
                
                # Print leave by type
                for leave_type, days in leave_by_type.items():
                    ax.text(0.1, y_pos, f"{leave_type}: {days} days", fontsize=10)
                    y_pos -= 0.05
                
                # Leave bar chart
                if len(leave_by_type) > 0:
                    y_pos -= 0.05
                    leave_ax = fig.add_axes([0.1, y_pos - 0.3, 0.8, 0.3])
                    
                    # Prepare data for chart
                    leave_types = leave_by_type.index.tolist()
                    leave_days = leave_by_type.values
                    
                    # Create bar chart
                    bars = leave_ax.bar(leave_types, leave_days, color='#1E88E5')
                    
                    # Add data labels
                    for bar in bars:
                        height = bar.get_height()
                        leave_ax.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                                    f"{height:.0f}",
                                    ha='center', va='bottom', fontsize=9)
                    
                    # Format axes
                    leave_ax.set_title("Leave Days by Type", fontsize=12)
                    leave_ax.set_ylabel("Days", fontsize=10)
                    leave_ax.grid(True, axis='y', linestyle='--', alpha=0.7)
                    
                    y_pos -= 0.35
                
                # Leave table
                y_pos -= 0.05
                ax.text(0.1, y_pos, "Recent Leave Records", fontsize=12, weight='bold')
                y_pos -= 0.05
                
                # Table headers
                col_labels = ['Start Date', 'End Date', 'Duration', 'Leave Type', 'Status']
                col_widths = [0.2, 0.2, 0.1, 0.25, 0.15]  # Proportional column widths
                
                # Calculate column positions
                col_positions = [0.1]  # Start position
                for width in col_widths[:-1]:
                    col_positions.append(col_positions[-1] + width)
                
                # Draw table headers
                for i, (label, pos) in enumerate(zip(col_labels, col_positions)):
                    ax.text(pos, y_pos, label, fontsize=9, weight='bold')
                
                y_pos -= 0.03
                ax.axhline(y=y_pos, xmin=0.1, xmax=0.9, color='black', linewidth=0.5)
                y_pos -= 0.03
                
                # Sort leave records by start date (descending)
                recent_leave = dept_leave.sort_values('start_date', ascending=False).head(10)
                
                # Draw table rows
                for _, row in recent_leave.iterrows():
                    start_date = row['start_date'].strftime('%d %b %Y')
                    end_date = row['end_date'].strftime('%d %b %Y')
                    duration = f"{row['duration_days']} days"
                    leave_type = row['leave_type']
                    status = row['status']
                    
                    # Print row values
                    ax.text(col_positions[0], y_pos, start_date, fontsize=8)
                    ax.text(col_positions[1], y_pos, end_date, fontsize=8)
                    ax.text(col_positions[2], y_pos, duration, fontsize=8)
                    ax.text(col_positions[3], y_pos, leave_type, fontsize=8)
                    ax.text(col_positions[4], y_pos, status, fontsize=8)
                    
                    y_pos -= 0.03
                    
                    # Stop if we're running out of space
                    if y_pos < 0.1:
                        break
                
                pdf.savefig(fig)
                plt.close()
        
        # Add a final page with legal disclaimer
        fig, ax = plt.subplots(figsize=(8.5, 11))
        ax.axis('off')
        
        # Page title
        ax.text(0.5, 0.95, "Legal Information", fontsize=16, weight='bold', ha='center')
        
        # Disclaimer
        disclaimer = [
            "This report contains confidential information and is intended solely for internal use.",
            "The information contained in this report may not be disclosed to any third party without prior consent.",
            "This report was generated automatically by the People Radar Dashboard system.",
            "The information is provided as-is and the company makes no guarantees about its accuracy or completeness.",
            "",
            f"Report generated on {datetime.now().strftime('%d %b %Y at %H:%M')}",
            f"Department: {department}"
        ]
        
        y_pos = 0.85
        for line in disclaimer:
            ax.text(0.1, y_pos, line, fontsize=10)
            y_pos -= 0.05
        
        pdf.savefig(fig)
        plt.close()
    
    # Reset buffer position to the beginning
    buffer.seek(0)
    
    return buffer